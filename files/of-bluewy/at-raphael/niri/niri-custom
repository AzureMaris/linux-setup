#!/usr/bin/env nu

let niri_env = {
   SDL_VIDEODRIVER: 'wayland,x11'
   CLUTTER_BACKEND: 'wayland'
   QT_QPA_PLATFORM: 'wayland;xcb'

   QT_QPA_PLATFORMTHEME: 'qt6ct'

   _JAVA_AWT_WM_NONREPARENTING: '1'
}

def main [
]: nothing -> nothing { }

def 'main start' [
   --systemd # Integrate with systemd.
]: nothing -> nothing {
   if $systemd {
      let systemd_pre_env = systemctl --user show-environment
      | lines
      | split column '=' key value

      mkdir ($env.XDG_RUNTIME_DIR | path join 'niri-custom')
      $systemd_pre_env | to json | save -f ($env.XDG_RUNTIME_DIR | path join 'niri-custom' 'systemd-pre-env.json')

      with-env $niri_env {
         systemctl --user import-environment ...($niri_env | columns)
         dbus-update-activation-environment ...($niri_env | columns)
      }

      systemctl --user start niri-custom.service

      loop {
         systemctl --user is-active --quiet niri-custom.service
         | complete
         | if ($in.exit_code == 0) {
            break
         }

         sleep 0.5sec
      }
   } else {
      let job_id = job spawn {
         with-env $niri_env {
            # remember to add back e>|
            niri --session | lines | take until {|line|
               let should_detach = $line | str contains 'IPC listening on:'

               if not $should_detach {
                  return false
               }

               # job disown $id # this is not yet implemented upstream
               $should_detach | job send 0
               $should_detach
            }
         }
      }

      job recv
   }

   systemctl --user start xwayland-satellite.service

   (
      run-single-instance-per-user
      --systemd=$systemd
      --process-name=io.elementary.desktop.agent-polkit
      '/usr/lib/policykit-1-pantheon/io.elementary.desktop.agent-polkit'
   )

   (
      run-single-instance-per-user
      --systemd=$systemd
      --process-name=qs
      --systemd-integrator-command=['runapp' '-i' 'session-graphical.slice']
      'qs' '-c' 'noctalia-shell'
   )

   run-single-instance-per-user --systemd=$systemd hypridle

   run-single-instance-per-user --systemd=$systemd wayland-pipewire-idle-inhibit
   run-single-instance-per-user --systemd=$systemd keepassxc
}

def 'main stop' []: nothing -> nothing {
   systemctl --user stop niri-custom.service
}

# With best effort, cleans up the environment.
# This is only necessary when used with systemd.
def 'main cleanup' []: nothing -> nothing {
   let systemd_pre_env = open ($env.XDG_RUNTIME_DIR | path join 'niri-custom' 'systemd-pre-env.json')

   let systemd_env = systemctl --user show-environment
   | lines
   | split column '=' key value

   let systemd_pre_and_now_env = $systemd_pre_env | join -o $systemd_env key

   let env_todos = $systemd_pre_and_now_env | par-each {|row|
      if $row.value == null {
         return {unset: $row.key}
      }

      if $row.value_ == null {
         return
      }

      if $row.value_ != $row.value {
         return {update: $row.key}
      }
   }

   let systemd_env_to_unset = $env_todos.unset? | compact
   let systemd_env_to_update = $env_todos.update? | compact

   if $systemd_env_to_unset != null and ($systemd_env_to_unset | is-not-empty) {
      systemctl --user unset-environment ...$systemd_env_to_unset
   }

   if $systemd_env_to_update != null and ($systemd_env_to_update | is-not-empty) {
      systemctl --user import-environment ...$systemd_env_to_update
   }

   rm ($env.XDG_RUNTIME_DIR | path join 'niri-custom' 'systemd-pre-env.json')
}

def run-single-instance-per-user [
   --user: string
   --systemd
   --systemd-integrator-command: list<string>
   --process-name: string
   ...command: string
] {
   let process_name = if ($process_name == null) {
      $command.0
   } else {
      $process_name
   }

   let user = if ($user == null) {
      $env.LOGNAME
   } else {
      $user
   }

   ps -l | where {|process|
      $process.name == $process_name and (id -nu $process.user_id) == $env.LOGNAME
   } | if ($in | is-empty) {
      try {
         if $systemd {
            if ($systemd_integrator_command | is-not-empty) {
               run-external ...$systemd_integrator_command ...$command
            } else {
               runapp ...$command
            }
         } else {
            run-external ...$command
         }
      } catch {|error|
         $error | print
      }
   }
}
