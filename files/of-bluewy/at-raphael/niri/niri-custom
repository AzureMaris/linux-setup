#!/usr/bin/env nu

def main [
]: nothing -> nothing { }

# Imports the environment defined in this script.
# This part is systemd only.
def 'main import-environment' [
]: nothing -> nothing {
   let script_runtime_dir = get-script-runtime-dir

   let script_runtime_dir = get-script-runtime-dir
   mkdir $script_runtime_dir

   let systemd_pre_env = systemctl --user show-environment
   | lines
   | split column '=' key value

   let systemd_pre_env_abs_file_path = get-systemd-pre-env-abs-file-path
   $systemd_pre_env | to json | save -f $systemd_pre_env_abs_file_path

   let wm_env = get-wm-env
   let wm_env_names = $wm_env | columns

   if ($wm_env_names | is-empty) {
      return
   }

   with-env $wm_env {
      systemctl --user import-environment ...$wm_env_names
      dbus-update-activation-environment ...$wm_env_names
   }
}

# Start niri in a custom way.
def 'main start' [
   --systemd # Whether to use systemd integration.
]: nothing -> nothing {
   if $systemd {
      systemctl --user start (get-wm-systemd-service-name)
   } else {
      let job_id = job spawn {
         with-env (get-wm-env) {
            niri --session | lines | take until {|line|
               let should_detach = $line | str contains 'IPC listening on:'

               if not $should_detach {
                  return false
               }

               $should_detach | job send 0
               $should_detach
            }
         }
      }

      job recv
      do-wm-autostart --systemd=$systemd
   }
}

# Stop niri.
def 'main stop' [
   --systemd # Whether systemd was used.
]: nothing -> nothing {
   if $systemd {
      systemctl --user stop (get-wm-systemd-service-name)
   } else {
      niri msg action quit
   }
}

# Cleans up the environment as best as possible.
# This is only needed with systemd.
def 'main cleanup' []: nothing -> nothing {
   let systemd_pre_env_abs_file_path = get-systemd-pre-env-abs-file-path
   let systemd_pre_env = open $systemd_pre_env_abs_file_path

   let systemd_post_env = systemctl --user show-environment
   | lines
   | split column '=' key value

   let systemd_env_diff = $systemd_pre_env | join -o $systemd_post_env key

   let env_name_todos = $systemd_env_diff | par-each {|row|
      match [$row.value $row.value_] {
         [null _] => { {unset: $row.key} }
         [_ null] => { }
         [_ _] => { {update: $row.key} }
      }
   }

   let systemd_env_names_to_unset = $env_name_todos.unset? | compact
   let systemd_env_names_to_update = $env_name_todos.update? | compact

   if $systemd_env_names_to_unset != null and ($systemd_env_names_to_unset | is-not-empty) {
      with-env (
         $systemd_env_names_to_unset | reduce -f {} {|systemd_env_name_to_unset acc|
            $acc | merge {$systemd_env_name_to_unset: ''}
         }
      ) {
         dbus-update-activation-environment ...$systemd_env_names_to_unset
      }

      systemctl --user unset-environment ...$systemd_env_names_to_unset
   }

   if $systemd_env_names_to_update != null and ($systemd_env_names_to_update | is-not-empty) {
      systemctl --user import-environment ...$systemd_env_names_to_update
      dbus-update-activation-environment ...$systemd_env_names_to_update
   }

   rm $systemd_pre_env_abs_file_path
}

# Does autostart that is defined in script.
def 'main autostart' [
   --systemd
] {
   do-wm-autostart --systemd=$systemd
}

def do-wm-autostart [
   --systemd
] {
   (
      run-single-instance-per-user
      --systemd=$systemd
      --systemd-wrapper-command=['runapp' '-i' 'session-graphical.slice']
      xwayland-satellite
   )

   (
      run-single-instance-per-user
      --systemd=$systemd
      --process-name=io.elementary.desktop.agent-polkit
      '/usr/lib/policykit-1-pantheon/io.elementary.desktop.agent-polkit'
   )

   (
      run-single-instance-per-user
      --systemd=$systemd
      --process-name=qs
      --systemd-wrapper-command=['runapp' '-i' 'session-graphical.slice']
      'qs' '-c' 'noctalia-shell'
   )

   run-single-instance-per-user --systemd=$systemd hypridle

   run-single-instance-per-user --systemd=$systemd wayland-pipewire-idle-inhibit
   run-single-instance-per-user --systemd=$systemd keepassxc
}

def get-wm-systemd-service-name []: nothing -> string {
   'niri-custom.service'
}

def get-wm-env []: nothing -> record {
   {
      DISPLAY: ':0' # also set niri's config

      SDL_VIDEODRIVER: 'wayland,x11'
      CLUTTER_BACKEND: 'wayland'
      QT_QPA_PLATFORM: 'wayland;xcb'

      QT_QPA_PLATFORMTHEME: 'qt6ct'

      _JAVA_AWT_WM_NONREPARENTING: '1'
   }
}

def get-systemd-pre-env-abs-file-path []: nothing -> string {
   get-script-runtime-dir | path join 'systemd-pre-env.json'
}

def get-script-runtime-dir []: nothing -> string {
   $env.XDG_RUNTIME_DIR | path join 'niri-custom'
}

def run-single-instance-per-user [
   --user: string
   --systemd
   --systemd-wrapper-command: list<string> = ['runapp']
   --process-name: string
   ...command: string
]: nothing -> nothing {
   let process_name = if ($process_name == null) {
      $command.0
   } else {
      $process_name
   }

   let user = if ($user == null) {
      $env.LOGNAME
   } else {
      $user
   }

   ps -l | where {|process|
      $process.name == $process_name and (id -nu $process.user_id) == $env.LOGNAME
   } | if ($in | is-empty) {
      try {
         if $systemd {
            run-external ...$systemd_wrapper_command ...$command
         } else {
            run-external ...$command
         }
      } catch {|error|
         $error | print
      }
   }
}
